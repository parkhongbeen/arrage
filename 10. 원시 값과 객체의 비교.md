# 10. 원시 값과 객체의 비교

자바스크립트가 제공하는 7가지 데이터타입은 크게 **원시타입과 객체타입**으로 구분할 수 있다.

- 원시 타입의 값, 즉 원시 값은 변경 불가능한 값(immutable value)이다. 이에 비해 객체(참조) 타입의 값, 즉 객체는 변경 가능한 값(mutable value)이다.
- 원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.
- 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달(Pass by value)라 한다. 이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달(Pass by reference)라 한다.



### 원시 값

#### 변경 불가능한 값

**원시 타입은 값,즉 원시 값은 변경 불가능한 값이다.**한번 생성된 원시값은 read only한 값이므로 변경할 수 없다.

값을 변경할 수 없다는 것은 재할당을 할 수 없다는 의미와는 다르다. 변수는 새로운 값을 재할당하는 것으로 변수값을 변경할 수 있다. 그렇기 때문에 변수라고 부른다. 변수에 상대 개념인 상수는 재할당이 금지된 변수를 말한다. 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수이다. 단, 변수는 언제든지 재할당을 통해 변수값을 변경할 수 있지만 상수는 단 한번만 할당이 허용된다. 따라서 상수와 변경 불가능한 값을 동일시하는 것은 곤란하다.

```
// const 키워드를 사용해 선언한 상수는 재할당이 금지된다.
const o = {};

// 하지만 const 키워드를 사용해 선언한 상수에 할당된 객체는 변경할 수 있다.
// 즉, 상수는 재할당이 금지된 변수일 뿐이다.
o.a = 1;
console.log(o); // {a: 1}
```

 원시 값을 할당한 변수에 새로운 원시 값을 재할당하면 변수는 재할당되기 이전의 값이 저장된 메모리 공간에 들어 있는 원시 값 자체를 수정하는 것이 아니라 새로운 메모리 공간을 확보하고 재할당한 원시 값을 저장한 후, 변수는 새롭게 재할당한 원시 값을 가리킨다. 만약 그렇다면 변수가 참조하던 메모리 공간의 주소가 바뀐다. 

 ![img](https://poiemaweb.com/assets/fs-images/10-1.png) 

변수가 참조하던 메모리 공간의 주소를 변경한 이유는 변수에 할당된 원시 값이 변경 불가능한 값이기 때문이다. 만약 원시 값이 변경 가능한 값이라면 변수에 새로운 원시 값을 재할당했을 때 변수가 가리키던 메모리 공간의 주소를 바꿀 필요없이 원시 값 자체를 수정하면 그만이다. 이때, 변수가 참조하던 메모리 공간의 주소는 바뀌지 않는다.

 ![img](https://poiemaweb.com/assets/fs-images/10-2.png) 

하지만 원시 값은 변경 불가능한 값이기 때문에 값을 직접 변경할 수 없다. 따라서 변수의 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경한다. 원시 값의 이러한 특성을 **불변성(immutability)**이라 한다.

#### 문자열과 불변성

자바스크립트는 개발자의 편의를 위해 원시 타입인 문자열 타입을 제공한다.즉,자바스크립트의 문자열은 원시 타입이며 변경 불가능하다.이것은 문자열이 생성되면,그 문자열을 변경할 수 없다는 것을 의미한다.

```
var str = 'Hello';
str = 'world';
```

첫번째 문(statement)이 실행되면 메모리에 문자열 ‘Hello’가 생성되고 식별자 str은 문자열 ‘Hello’가 저장된 메모리 공간의 첫번째 셀의 주소를 가리킨다. 그리고 두번째 문이 실행되면 이전에 생성된 문자열 ‘Hello’을 수정하는 것이 아니라 새로운 문자열 ‘world’를 메모리에 생성하고 식별자 str은 이것을 가리킨다. 이때 문자열 ‘Hello’와 ‘world’는 모두 메모리에 존재하고 있다. 식별자 str은 문자열 ‘Hello’를 가리키고 있다가 문자열 ‘world’를 가리키도록 변경되었을 뿐이다.

문자열은 유사 배열 객체이므로 배열과 유사하게 각 문자에 접근할 수 있다.

**유사배열 객체** - 유사배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length프로퍼티를 갖는 객체를 말한다.문자열은 마치 배열처럼 인덱스를 통해 각 문자에 접근할 수 있으며 length프로퍼티를 갖기 때문에 for문으로 순회할 수도 있다.

```
let str = 'hong';

str[0] = 'H';

console.log(str[0]); // h
//이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않는다
//한번 생성된 문자열은 원시값이기 떄문에 read only로서 변경할 수 없다.
```

### 값에 의한 전달

```
var score = 10;
var copy = score;

copy = 20;
console.log(score); //10
```

변수 score에 숫자값 80을 할당했다. 그리고 변수 copy에 변수 score를 할당했다. 그 후, 변수 copy에 새로운 숫자값 100을 재할당하면 변수 score의 값은 어떻게 될까? 이 질문의 핵심은 “변수에 변수를 할당했을 때 무엇이 어떻게 전달되는가?”이다.

변수에 변수를 할당하는 경우, 할당되는 변수(score)가 원시값을 갖는 변수라면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시값이 복사되어 전달된다. 이를 **값에 의한 전달(Pass by value)**라 한다.

위 예제의 경우, 변수 copy에 변수 score를 할당하면 변수 score의 원시값이 복사되어 변수 copy에 할당된다.



```
var score = 80;

// 변수 copy에는 변수 score의 원시값 80이 복사되어 할당된다.
var copy = score;

console.log(score, copy); // 80  80
console.log(score === copy); // true
```

이때 변수 score와 copy는 80이라는 숫자값을 갖는다는 점에서는 동일하다.하지만 변수 score와 copy의 값 80은 다른 메모리 공간에 저장된 별개의 값이다.

 

![img](https://poiemaweb.com/assets/fs-images/10-3.png)

```
var score = 80;

// 변수 copy에는 변수 score의 원시값 80이 복사되어 할당된다.
var copy = score;

console.log(score, copy);    // 80  80
console.log(score === copy); // true

// 변수 score와 변수 copy의 값은 다른 메모리 공간에 저장된 별개의 값이다.
// 따라서 변수 copy의 값을 변경하여도 변수 score의 값에는 어떠한 영향도 주지 않는다.
copy = 100;

console.log(score, copy);    // 80  100
console.log(score === copy); // false
```

변수 score와 copy의 값 80은 다른 메모리 공간에 저장된 별개의 값이라는 것에 주의하기 바란다. 따라서 변수 copy의 값을 변경하여도 변수 score의 값에는 어떠한 영향도 주지 않는다.

### 객체

객체는 프로퍼티의 개수가 정해져있지 않으며 동적으로 추가되고 삭제할 수 있다.

또한 프로퍼티의 값에도 제약이 없다 따라서 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.

### 변경 가능한 값

객체타입의 값,즉 객체는 변경 가능한 값이다.먼저 변수에 객체를 할당하면 어떤일이 일어나는지부터 살펴보자

```
var person = {
 name: 'Park'
};
```

원시 값을 할당한 변수는 원시 값 자체를 값으로 갖는다.하지만,객체를 할당한 변수는 **참조값(Reference value)을 값으로 갖는다.참조 값은 생성된 객체가 저장된 메모리 공간의 주소,그 자체이다.

원시 값을 갖는 변수의 값을 변경하려면 재할당 이외에는 다른 방법이 없다. 변수가 가리키는 객체는 생성된 이후에도 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수도 있다. 다시 말해, 객체는 변경할 수 있는 값이다.

```
var person = {
  name: 'Lee'
};

// 프로퍼티 값 갱신
person.name = 'Kim';

// 프로퍼티 동적 추가
person.address = 'Seoul';

console.log(person); // {name: "Kim", address: "Seoul"}
```

**얕은 복사과 깊은 복사**

 객체를 프로퍼티 값으로 갖는 객체의 경우, 얕은 복사는 한 단계까지만 복사하는 것을 말하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하는 것을 말한다.
얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체이다. 즉, 원본과 복사본은 참조값이 다른 별개의 객체이다. 하지만 얕은 복사는 객체에 중첩되어 있는 객체의 경우, 참조값을 복사하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하여 원시 값처럼 완전한 복사본을 만든다는 차이가 있다. 

### 참조에 의한 전달

```
var person = {
  name: 'Lee'
};

// 참조 값을 복사
var copy = person;
```

객체를 가리키는 변수를 다른변수에 할당하면 원본의 참조 값이 복사되어 전달된다.이를 **참조에 의한 전달**이라고 한다.

```
var person = {
  name: 'Lee'
};

// 참조 값을 복사. copy와 person은 동일한 객체를 참조한다.
var copy = person;

// copy와 person은 같은 참조 값을 갖는다.
console.log(copy === person); // true

// copy를 통해 객체를 변경한다.
copy.name = 'Kim';

// person을 통해 객체를 변경한다.
person.address = 'Seoul';

// copy와 person은 같은 동일한 가리키고 있다.
// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.
console.log(person); // {name: "Kim", address: "Seoul"}
console.log(copy);   // {name: "Kim", address: "Seoul"}
```

